using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D; // Added this line
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.IO;
using System.Threading;
using System.Drawing.Imaging; // For BitmapData and PixelFormat
using System.Runtime.InteropServices; // For the Marshal class


namespace Origami
{
    /*
     * 
Parsing of various XML templates
Format design:
3D and 2D design. Mapping association??
Since the content is known, a simple data structure can be designed to represent the relevant graphics.
Mapping association between 2D files and 3D images
Test the styles of 3D graphics generated by all 2D templates
Including tetrahedrons and hexahedrons
Random unit generation (hollowed-out or other specified graphics)
Triangles are relatively more complex
What about quadrilaterals? Is boundary judgment easier?
Render 2D content into images
3D rendering
Render multiple 3D models into images
Attempt design
Export design:
2D -> 3D
Select any flat 2D template and generate patterns randomly
11 + 2 = 13 templates; generate random graphics (e.g., 20 samplings)
Generate standard answers: images rendered from 3D graphics
Disturbance 1: Generate interfering answers; adjust the scheme for directional patterns
Disturbance 2: For non-centered graphics, appropriately offset the position??
Disturbance 3: Change the relative positions of data (e.g., adjacent positions, opposite positions)
Two question formats:
Question 1: Which image is NOT generated by the template? (1 incorrect option) (if interfering options are designed specifically)
Question 2: Which pattern IS generated by the template? (3 incorrect options)
For 3D-to-2D conversion: How to unfold???? For any given 3D model, provide multiple views??
Design question types? Generate 3D images based on 2D templates, and reversely display the 3D model as various adjacent graphics??
Are there also 2 types of question formats??
Representation method for arrangements


Based on the 6 faces of a cube:
F (Front face), B (Back face) (opposite faces);U (Upper face), D (Lower face) (opposite faces);L (Left face), R (Right face) (opposite faces).
By fixing the front face (F=1, using symmetry to eliminate rotational redundancy), we discuss the possible values of the back face (B) (ranging from 2 to 6) in 5 categories. Each category corresponds to 6 permutations of the remaining 4 numbers (U, R, D, L), resulting in a total of 30 types.30 distinct arrangements (with F=1 fixed)Category 1: Back face B=2 (remaining numbers: 3, 4, 5, 6)

Category 1: Back face B=2 (remaining numbers: 3, 4, 5, 6)
(F=1, B=2, U=3, R=4, D=5, L=6)
(F=1, B=2, U=3, R=4, D=6, L=5)
(F=1, B=2, U=3, R=5, D=4, L=6)
(F=1, B=2, U=3, R=5, D=6, L=4)
(F=1, B=2, U=3, R=6, D=4, L=5)
(F=1, B=2, U=3, R=6, D=5, L=4)


Category 2: Back face B=3 (remaining numbers: 2, 4, 5, 6)
(F=1, B=3, U=2, R=4, D=5, L=6)
(F=1, B=3, U=2, R=4, D=6, L=5)
(F=1, B=3, U=2, R=5, D=4, L=6)
(F=1, B=3, U=2, R=5, D=6, L=4)
(F=1, B=3, U=2, R=6, D=4, L=5)
(F=1, B=3, U=2, R=6, D=5, L=4)


Category 3: Back face B=4 (remaining numbers: 2, 3, 5, 6)
(F=1, B=4, U=2, R=3, D=5, L=6)
(F=1, B=4, U=2, R=3, D=6, L=5)
(F=1, B=4, U=2, R=5, D=3, L=6)
(F=1, B=4, U=2, R=5, D=6, L=3)
(F=1, B=4, U=2, R=6, D=3, L=5)
(F=1, B=4, U=2, R=6, D=5, L=3)


Category 4: Back face B=5 (remaining numbers: 2, 3, 4, 6)
(F=1, B=5, U=2, R=3, D=4, L=6)
(F=1, B=5, U=2, R=3, D=6, L=4)
(F=1, B=5, U=2, R=4, D=3, L=6)
(F=1, B=5, U=2, R=4, D=6, L=3)
(F=1, B=5, U=2, R=6, D=3, L=4)
(F=1, B=5, U=2, R=6, D=4, L=3)


Category 5: Back face B=6 (remaining numbers: 2, 3, 4, 5)
(F=1, B=6, U=2, R=3, D=4, L=5)
(F=1, B=6, U=2, R=3, D=5, L=4)
(F=1, B=6, U=2, R=4, D=3, L=5)
(F=1, B=6, U=2, R=4, D=5, L=3)
(F=1, B=6, U=2, R=5, D=3, L=4)
(F=1, B=6, U=2, R=5, D=4, L=3)

The 30 arrangements above cover all the number arrangement patterns of a cube that cannot overlap with each other through rotation.

     * 
     
     */


    public class Folding3DUtils
    {
        // Initialize a 2D array for the 30 cube arrangements with dimensions [30, 6]
        // (F=1, B=2, U=3, R=4, D=5, L=6)


        //FBURDL
        public static int[] _faceMap = new int[] { 0, 2, 4, 1, 5, 3 };

        public static int[,] _faceMapGroup = new int[24, 6]
        {
            {0,2,4,1,5,3 },  //123456
            {0,2,1,5,3,4},   //163524
            {0,2,5,3,4,1},  //143265  
            {0,2,3,4,1,5}, //153642,

            {1,3,4,2,5,0}, //234156
            {1,3,0,4,2,5}, //254613
            {1,3,5,0,4,2},  //214365
            {1,3,2,5,0,4},  //264531 
  
            {2,0,4,3,5,1},  //341256
            {2,0,1,4,3,5},  //351624
            {2,0,5,1,4,3},  //321465
            {2,0,3,5,1,4},  //361542

            {3,1,4,0,5,2},  //412356
            {3,1,2,4,0,5},  //452631
            {3,1,5,2,4,0},  //432165
            {3,1,0,5,2,4},  //462513

            {4,5,2,1,0,3},  //526431
            {4,5,3,2,1,0},  //536142
            {4,5,0,3,2,1},  //546213
            {4,5,1,0,3,2},  //516324

            {5,4,0,1,2,3},  //625413
            {5,4,3,0,1,2},  //615342
            {5,4,2,3,0,1},  //645231
            {5,4,1,2,3,0},  //635124
        };

        public static int[,] _cubeArrangements = new int[30, 6]
        {
            // Category 1: B=2 (Remaining numbers: 3, 4, 5, 6)
            { 1, 2, 3, 4, 5, 6 },
            { 1, 2, 3, 4, 6, 5 },
            { 1, 2, 3, 5, 4, 6 },
            { 1, 2, 3, 5, 6, 4 },
            { 1, 2, 3, 6, 4, 5 },
            { 1, 2, 3, 6, 5, 4 },

            // Category 2: B=3 (Remaining numbers: 2, 4, 5, 6)
            { 1, 3, 2, 4, 5, 6 },
            { 1, 3, 2, 4, 6, 5 },
            { 1, 3, 2, 5, 4, 6 },
            { 1, 3, 2, 5, 6, 4 },
            { 1, 3, 2, 6, 4, 5 },
            { 1, 3, 2, 6, 5, 4 },

            // Category 3: B=4 (Remaining numbers: 2, 3, 5, 6)
            { 1, 4, 2, 3, 5, 6 },
            { 1, 4, 2, 3, 6, 5 },
            { 1, 4, 2, 5, 3, 6 },
            { 1, 4, 2, 5, 6, 3 },
            { 1, 4, 2, 6, 3, 5 },
            { 1, 4, 2, 6, 5, 3 },

            // Category 4: B=5 (Remaining numbers: 2, 3, 4, 6)
            { 1, 5, 2, 3, 4, 6 },
            { 1, 5, 2, 3, 6, 4 },
            { 1, 5, 2, 4, 3, 6 },
            { 1, 5, 2, 4, 6, 3 },
            { 1, 5, 2, 6, 3, 4 },
            { 1, 5, 2, 6, 4, 3 },

            // Category 5: B=6 (Remaining numbers: 2, 3, 4, 5)
            { 1, 6, 2, 3, 4, 5 },
            { 1, 6, 2, 3, 5, 4 },
            { 1, 6, 2, 4, 3, 5 },
            { 1, 6, 2, 4, 5, 3 },
            { 1, 6, 2, 5, 3, 4 },
            { 1, 6, 2, 5, 4, 3 }
        };


        // Initialize a 2D array for the 2 tetrahedron arrangements with dimensions [2, 4]
        // Each row corresponds to one arrangement; column order: Face 0, Face 1, Face 2, Face 3

        public static int[,] _tetraArrangements = new int[2, 4]
        {
            { 1, 2, 3, 4 },  // first
            { 1, 2, 4, 3 }   // second
        };




        // Example 1: Generate an image using default parameters
        public static Bitmap[] GenerateDefaultImages()
        {
            return RandomImageGenerator.Generate6Images(null);
        }

        // Example 2: Generate an image containing only geometric figures and arrows
        public static Bitmap[] GenerateGeoArrowImages()
        {
            ImageGenerationOptions options = new ImageGenerationOptions
            {
                Size = 128,
                Categories = ImageCategory.Geometric | ImageCategory.Arrow,
                GeoUseRandomColors = true,
                AllowDuplicates = false
            };

            return RandomImageGenerator.Generate6Images(options);
        }

        // Example 3: Generate a line pattern with high line density
        public static Bitmap[] GenerateHighDensityLineImages()
        {
            ImageGenerationOptions options = new ImageGenerationOptions
            {
                Categories = ImageCategory.Lines,
                LineDensity = 30, // High-density lines
                Size = 200
            };

            return RandomImageGenerator.Generate6Images(options);
        }

        public static List<int> GetUniqueRandomNumbers(int N, int num)
        {
            // Verify the validity of parameters
            int maxPossible = N + 1; // A total of N+1 numbers from 0 to N

            // Scenario 1: When num is close to N (e.g., N=100, num=80), the shuffle algorithm is more efficient (avoids frequent deduplication)
            if (num >= maxPossible * 0.5) // The threshold can be adjusted; 50% is used as the cutoff here
            {
                // Generate the full sequence
                List<int> allNumbers = Enumerable.Range(0, maxPossible).ToList();
                Random random = new Random();
                // Shuffle (use a temporary variable for swapping, compatible with .NET Framework 4)
                for (int i = allNumbers.Count - 1; i > 0; i--)
                {
                    int j = random.Next(i + 1);
                    // Traditional swap method (instead of tuple assignment)
                    int temp = allNumbers[i];
                    allNumbers[i] = allNumbers[j];
                    allNumbers[j] = temp;
                }
                return allNumbers.Take(num).ToList();
            }
            // Scenario 2: num is much smaller than N (e.g., N=10000, num=3); random generation + deduplication is more efficient
            else
            {
                HashSet<int> resultSet = new HashSet<int>();
                Random random = new Random();
                // Loop to generate random numbers until we collect num unique values
                while (resultSet.Count < num)
                {
                    int randomNum = random.Next(0, maxPossible); // Generate a random number from 0 to N
                    resultSet.Add(randomNum); // HashSet automatically deduplicates; duplicate numbers are ignored
                }
                return resultSet.ToList();
            }
        }


        public static Bitmap GetSubBitmap(Bitmap source, Rectangle rect)
        {
            if (source == null)
                throw new ArgumentNullException("source", "Source Bitmap cannot be null");

            // Ensure the rectangle is within the source image bounds
            if (rect.X < 0 || rect.Y < 0 ||
                rect.Right > source.Width ||
                rect.Bottom > source.Height)
            {
                throw new ArgumentException("The rectangle region is outside the bounds of the source image", "rect");
            }

            // Clone the specified region of the image
            return source.Clone(rect, source.PixelFormat);
        }
    }

}